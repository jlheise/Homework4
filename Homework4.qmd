---
title: "Homework4"
author: "Jessie Heise"
format: pdf
editor: visual
---

```{r, echo = FALSE, message = FALSE, warning = FALSE}
library(tidyverse)
```

## Task 1: Conceptual Questions

### Question 1

The purpose of the lapply() function is to apply a function to every element of a list. The equivalent purrr function is map().

### Question 2

lapply(x = my_list, FUN = cor(numeric_matrix), method = "kendall")

### Question 3

One advantage of using purrr functions instead of the BaseR apply family is that purrr functions provide a more consistent and clean way to apply functions to objects. Another advantage is that purrr functions allow for shorthand and have additional helper functions.

### Question 4

A side-effect function is a type of pipeable function that doesn't actually try to change the data, it just tries to produce something. The print() and plot() functions are examples of side-effect functions.

### Question 5

You can name a variable sd in a function and not cause any issues with the sd function because of lexical scoping. Lexical scoping is how R looks up where to get the object from.

## Task 2: Writing R Functions

### Question 1

```{r}
#Write getRMSE function
getRMSE <- function(response_input,prediction_input,...){
  RMSE <- sqrt(mean((response_input - prediction_input)^2,...))
}
```

### Question 2

```{r}
#Run code from assignment to create some response values and predictions
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10*x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))

#Test RMSE function using this data
testRMSE <- getRMSE(resp,pred)

#Replace two of the response values with missing values (NA_real_)
resp2 <- resp
resp2[c(1,2)] <- c(NA_real_,NA_real_)

#Test getRMSE with specifying behavior to deal with missing values
testRMSE2 <- getRMSE(resp2,pred,na.rm=TRUE)

#Test getRMSE without specifying behavior to deal with missing values
testRMSE3 <- getRMSE(resp2,pred)
```

### Question 3

```{r}
#getMAE() function that evaluates predictions using mean absolute deviation
getMAE <- function(response_input, prediction_input,...){
  MAE <- sqrt(mean(abs(response_input - prediction_input),...)) 
}
```

### Question 4

```{r}
#Run code from assignment to create some response values and predictions
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10*x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))

#Test MAE function using this data
testMAE <- getMAE(resp,pred)

#Replace two of the response values with missing values (NA_real_)
resp2 <- resp
resp2[c(1,2)] <- c(NA_real_,NA_real_)

#Test getMAE with specifying behavior to deal with missing values
testMAE2 <- getMAE(resp2,pred,na.rm=TRUE)

#Test getMAE without specifying behavior to deal with missing values
testMAE3 <- getMAE(resp2,pred)
```

### Question 5
